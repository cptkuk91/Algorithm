function solution(n) {
  let newArr = [0, 1];

  let fibo = (n) => {
    //   만약 기존에 저장된 값일 경우 newArr[n]을 출력한다.
    if (newArr[n] !== undefined) {
      return newArr[n];
    }
    // 반대로 newArr[n]없는 값이라면 아래의 공식을 따른다.
    // 피보나치 공식은 (n - 1) + (n - 2)다.
    newArr[n] = fibo(n - 1) + fibo(n - 2);
    return newArr[n];
  };
  return fibo(n);
}

// 피보나치를 실제 프로그래밍에 적용한다면?
/*
피보나치는 다이나믹 프로그래밍의 대표적인 예시다. 큰 문제를 작은 문제로 쪼개서 문제를 효율적으로 해결할 수 있다.

그럼 더 큰문제를 작은 문제로 쪼개는 경우가 무엇이 있을까?

캐싱과 메모리제이션입니다.

캐싱이란 데이터 집합을 저장하는 스토리지 계층으로 캐싱을 사용하면 이전 검색, 계산한 데이터를 효율적으로 재사용할 수 있습니다.

메모리제이션이란 동일한 계산을 반복해야할 때, 이전에 계산한 값을 메모리에 저장해 동일한 계산의 반복 수행을 제거해 프로그램 실행 속도를 빠르게 하는 기술입니다.
*/
